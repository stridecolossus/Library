package org.sarge.lib.xml;

import static java.util.stream.Collectors.joining;
import static java.util.stream.Collectors.toList;
import static org.sarge.lib.util.Check.notEmpty;
import static org.sarge.lib.util.Check.notNull;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.stream.Stream;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.builder.EqualsBuilder;
import org.sarge.lib.collection.StrictMap;
import org.sarge.lib.util.Converter;
import org.sarge.lib.util.StreamUtil;
import org.sarge.lib.util.ValueConverter;

/**
 * An element is an immutable node in an XML tree.
 * <p>
 * Element attributes can be accessed using {@link #attribute(String)} and transformed into primitive values, e.g. {@link Attribute#toInteger()} or custom types using a converter, e.g. {@link Attribute#toValue(Converter)}.
 * All attribute accessors have an alternative version that allows a default for a missing value (i.e. non-mandatory attributes).
 * All attribute accessors and transformers throw {@link NumberFormatException} for invalid or missing mandatory values.
 * <p>
 * The XML tree can be navigated using various accessors:
 * <ul>
 * <li>{@link #parent()} returns the parent of an element, see {@link #isRoot()}</li>
 * <li>{@link #children()} enumerates the children of an element</li>
 * <li>{@link #child()} and {@link #find()} return a <b>single</b> child element</li>
 * <li>All the above have alternate convenience versions that find elements by name</li>
 * </ul>
 * The {@link #exception(String)} method is used to raise an exception caused by a given element.
 * <p>
 * Generally elements are constructed using a {@link Builder} or {@link #of(String)} for a simple root element.
 * <p>
 * @author Sarge
 */
public final class Element {
	/**
	 * Creates a simple root element.
	 * @param name Element name
	 */
	public static Element of(String name) {
		return new Element(name, Map.of(), StringUtils.EMPTY);
	}

	/**
	 * Exception generated by an XML element.
	 * <p>
	 * The exception message prints the slash-delimited path from the root to the offending element with sibling indices indicated by square brackets,
	 * e.g. <tt>/root/sibling[2]/another/child[3]</tt>
	 */
	public class ElementException extends RuntimeException {
		private String filename;

		/**
		 * Constructor.
		 * @param reason Reason message
		 */
		private ElementException(String reason) {
			super(reason);
		}

		/**
		 * Constructor for wrapping an underlying exception.
		 * @param e Underlying exception
		 */
		private ElementException(Exception e) {
			super(e);
		}

		/**
		 * @return Element that caused this exception
		 */
		public Element element() {
			return Element.this;
		}

		/**
		 * Sets the filename associated with this exception.
		 * @param filename Filename
		 */
		public void setFile(String filename) {
			this.filename = notNull(filename);
		}

		@Override
		public String getMessage() {
			final String path = Element.this.path().map(this::build).collect(joining("/"));
			final StringBuilder sb = new StringBuilder();
			sb.append(super.getMessage());
			sb.append(" at /");
			sb.append(path);
			if(filename != null) {
				sb.append(" in ");
				sb.append(filename);
			}
			return sb.toString();
		}

		/**
		 * Builds the path element description of the given element.
		 * @param element Element
		 * @return Path element description
		 */
		private String build(Element element) {
			final String name = element.name;
			if(element.parent == null) {
				// Root element
				return name;
			}
			else {
				// Child element
				final var children = element.parent.children(name).collect(toList());
				if(children.size() == 1) {
					// Single sibling element
					return name;
				}
				else {
					// Build sibling index of the element
					final int index = indexOf(children, element);
					assert index >= 0;
					final StringBuilder sb = new StringBuilder();
					sb.append(name);
					sb.append("[");
					sb.append(index + 1);
					sb.append("]");
					return sb.toString();
				}
			}
		}

		/**
		 * Finds the sibling index of the specified element using reference equality.
		 */
		private int indexOf(List<Element> list, Element element) {
			int index = 0;
			for(Element e : list) {
				if(e == element) return index;
				++index;
			}
			throw new RuntimeException();
		}
	}

	/**
	 * Attribute of this element.
	 */
	public class Attribute extends ValueConverter {
		private final String attr;
		private final String value;

		/**
		 * Constructor.
		 * @param name Attribute name
		 */
		private Attribute(String name) {
			this.attr = notEmpty(name);
			this.value = attributes.get(name);
		}

		@Override
		protected String get() {
			return value;
		}

		/**
		 * @return Whether this attribute is present
		 */
		public boolean isPresent() {
			return value != null;
		}

		/**
		 * Maps this attribute to an optional value using the given converter.
		 * @param converter Converter
		 * @return Optional attribute value
		 * @throws NumberFormatException if the value is present but cannot be converted
		 */
		public <T> Optional<T> optional(Converter<T> converter) {
			if(value == null) {
				return Optional.empty();
			}
			else {
				return Optional.of(converter.apply(value));
			}
		}

		/**
		 * Maps this attribute to an optional string.
		 * @return Optional attribute value
		 */
		public Optional<String> optional() {
			if(value == null) {
				return Optional.empty();
			}
			else {
				return Optional.of(value);
			}
		}

		@Override
		public <T> T toValue(T def, Converter<T> converter) {
			try {
				return super.toValue(def, converter);
			}
			catch(IllegalArgumentException e) {
				throw new ElementException(e.getMessage());
			}
		}

		@Override
		public boolean equals(Object that) {
			return EqualsBuilder.reflectionEquals(this, that);
		}

		@Override
		public String toString() {
			final StringBuilder sb = new StringBuilder();
			sb.append("[");
			sb.append(attr);
			sb.append(" -> ");
			sb.append(String.valueOf(value));
			sb.append("]");
			return sb.toString();
		}
	}

	private final String name;
	private final Map<String, String> attributes;
	private final String text;
	private final List<Element> children = new ArrayList<>();
	private Element parent;

	/**
	 * Constructor.
	 * @param name				Element name
	 * @param attributes		Attributes as a key-value map
	 * @param text				Element text content
	 */
	private Element(String name, Map<String, String> attributes, String text) {
		this.name = notEmpty(name);
		this.attributes = Map.copyOf(attributes);
		this.text = notNull(text);
	}

	/**
	 * Copy constructor.
	 * <p>
	 * Notes:
	 * <ul>
	 * <li>This constructor creates a <i>deep</i> copy of the element, i.e. recursively clones the entire XML tree starting at this element.</li>
	 * <li>The resultant copy is a <i>root</i> element</li>
	 * </ul>
	 * @param element Element to copy
	 */
	public Element(Element element) {
		this(element.name, element.attributes, element.text);
		element.children.stream().map(Element::new).forEach(this.children::add);
	}

	/**
	 * @return Element name
	 */
	public String name() {
		return name;
	}

	/**
     * @return Textual content of this element
     */
    public String text() {
        return text;
    }

	/**
	 * @return Parent of this element or <tt>null</tt> for the document root
	 */
	public Element parent() {
		return parent;
	}

	/**
	 * @return Whether this is a root element
	 */
	public boolean isRoot() {
		return parent == null;
	}

	/**
	 * Sets the parent of this element.
	 * @param parent Parent
	 */
	private void add(Element child) {
		assert child.isRoot();
		child.parent = this;
		children.add(child);
	}

	/**
	 * Looks up an attribute.
	 * @param name Attribute name
	 * @return Attribute
	 */
	public Attribute attribute(String name) {
		return new Attribute(name);
	}

	/**
	 * @return Children of this element
	 */
	public Stream<Element> children() {
		return children.stream();
	}

	/**
	 * Convenience accessor to retrieve children with the given name.
	 * @return Children of this element
	 */
	public Stream<Element> children(String name) {
		return children.stream().filter(e -> e.name().equals(name));
	}

	/**
	 * @return The <b>single</b> child of this element
	 * @throws ElementException if this element does not have exactly <b>one</b> child
	 */
	public Element child() throws ElementException {
        if(children.size() == 1) {
            return children.get(0);
        }
        else {
            throw exception("Expected ONE child element");
        }
	}

    /**
     * @param name Child name
     * @return The <b>single</b> child of this element with the given name
     * @throws ElementException if this element does not have exactly <b>one</b> child with the given name
     */
    public Element child(String name) throws ElementException {
        final Iterator<Element> itr = children(name).iterator();
        if(itr.hasNext()) {
            final Element child = itr.next();
            if(!itr.hasNext()) return child;
        }
        throw exception("Expected ONE named child element: " + name);
    }

    /**
     * Finds the <b>single</b> child element.
     * @return Optional child element
     */
    public Optional<Element> find() {
        if(children.size() == 1) {
            return Optional.of(children.get(0));
        }
        else {
            return Optional.empty();
        }
    }

    /**
     * Finds the <b>single</b> child element with the given name
     * @param name Child name
     * @return Optional child with the given name
     */
    public Optional<Element> find(String name) {
        return StreamUtil.findOnly(children(name));
    }

    /**
     * @return Path from the root to this element
     */
    public Stream<Element> path() {
    	final var path = Stream.iterate(this, Objects::nonNull, Element::parent).collect(toList());
        Collections.reverse(path);
        return path.stream();
    }

    /**
     * Creates an exception caused by this element.
     * @param reason Reason message
     * @return Element exception
     */
    public ElementException exception(String reason) {
        return new ElementException(reason);
    }

    /**
     * Wraps the given exception.
     * @param e Underlying exception
     * @return Element exception
     */
    public ElementException exception(Exception e) {
        return new ElementException(e);
    }

    @Override
    public boolean equals(Object that) {
    	return EqualsBuilder.reflectionEquals(this, that);
    }

    @Override
	public String toString() {
		return name;
	}

	/**
	 * Builder for an {@link Element}.
	 * <p>
	 * Note that non-root elements <b>cannot</b> be added to an XML tree using {@link #add(Element)} without first being cloned.
	 * <p>
	 * Example usage:
	 * <pre>
	 * // Building an XML tree
	 * final Element root = new Element.Builder("root")
	 *     .attribute("name", "value")
	 *     .text("text")
	 *     .build();
	 *
	 * // Building child elements
	 * new Element.Builder("root")
	 *     .begin("child")
	 *         .attribute(...)
	 *         .end();
	 *     .child(child)
	 *     .child("child")
	 *     .build();
	 * </pre>
	 */
	public static class Builder {
		// Properties
		private final String name;
		private final Map<String, String> attributes = new StrictMap<>();
		private String text = StringUtils.EMPTY;

		// Tree
		private final List<Element> children = new ArrayList<>();
		private Builder parent;

		/**
		 * Constructor.
		 * @param name Element name
		 */
		public Builder(String name) {
			this.name = notEmpty(name);
		}

		/**
		 * Sets the textual content of this element.
		 * @param text Text
		 */
		public Builder text(String text) {
			this.text = text;
			return this;
		}

		/**
		 * Adds an attribute to this element.
		 * @param name		Attribute name
		 * @param value		Value
		 * @throws NullPointerException if the given value is <tt>null</tt>
		 * @throws IllegalArgumentException for a duplicate attribute
		 */
		public Builder attribute(String name, Object value) {
			attributes.put(name, value.toString());
			return this;
		}

		/**
		 * Attaches a child element.
		 * <p>
		 * Note that elements are immutable and cannot be added to multiple XML trees without first being cloned using the {@link Element#Element(Element)} copy constructor.
		 * @param child Child element to attach
		 * @throws IllegalArgumentException if the given element is not a root
		 * @see Element#isRoot()
		 * @see Element#Element(Element)
		 */
		public Builder add(Element child) {
			if(child.parent != null) throw new IllegalArgumentException("Only a root element can be added: " + child);
			children.add(child);
			return this;
		}

		/**
		 * Convenience method to add a simple child element.
		 * @param child Child element name
		 * @see #add(Element)
		 */
		public Builder add(String child) {
			add(Element.of(child));
			return this;
		}

		/**
		 * Begins a new child element.
		 * @param name Child element name
		 * @return Child element builder
		 * @see #end()
		 */
		public Builder child(String name) {
			final Builder child = new Builder(name);
			child.parent = this;
			return child;
		}

		/**
		 * Ends the current child element.
		 * @return Parent element builder
		 * @throws IllegalStateException if this is not a child element builder
		 */
		public Builder end() {
			if(parent == null) throw new IllegalStateException("Cannot end a root element");
			final Element child = buildLocal();
			parent.children.add(child);
			return parent;
		}

		/**
		 * Constructs this element.
		 * @return New element
		 * @throws IllegalStateException if this is a child element builder
		 */
		public Element build() {
			if(parent != null) throw new IllegalStateException("Cannot build a child element");
			return buildLocal();
		}

		/**
		 * Constructs this element.
		 * @return New element
		 */
		private Element buildLocal() {
			// Build this element
		    final Element element = new Element(name, attributes, text);

		    // Attach children
		    for(Element child : children) {
		    	element.add(child);
		    }

		    return element;
		}
	}
}

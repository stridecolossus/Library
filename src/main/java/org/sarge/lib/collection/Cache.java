package org.sarge.lib.collection;

import static org.sarge.lib.util.Check.notNull;
import static org.sarge.lib.util.Check.zeroOrMore;

import java.util.Comparator;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.Map;
import java.util.Queue;
import java.util.function.Supplier;
import java.util.stream.Collectors;

import org.junit.platform.commons.util.ToStringBuilder;
import org.sarge.lib.util.AbstractObject;

/**
 * In-memory cache.
 * @author Sarge
 * @param <K> Key type
 * @param <V> Value type
 */
public class Cache<K, V> {
	/**
	 * Cache entry.
	 * @param <T> Value type
	 */
	public static class Entry<T> {
		private final T value;
		private final int weight;

		private long latest;
		private int count;

		/**
		 * Constructor.
		 * @param value			Value
		 * @param weight		Weight of this entry
		 */
		private Entry(T value, int weight) {
			this.value = notNull(value);
			this.weight = zeroOrMore(weight);
			update();
		}

		/**
		 * Updates latest access time.
		 */
		private void update() {
			this.latest = System.currentTimeMillis();
		}
	}

	/**
	 * Cache eviction policy.
	 */
	@FunctionalInterface
	public interface EvictionPolicy {
		/**
		 * Calculates the eviction score for the given entry.
		 * @param entry Entry
		 * @return Score
		 */
		long score(Entry<?> entry);

		/**
		 * Empty eviction policy.
		 */
		EvictionPolicy NONE = entry -> {
			throw new UnsupportedOperationException();
		};

		/**
		 * Eviction policy based on recent access.
		 */
		EvictionPolicy LEAST_RECENTLY_USED = entry -> entry.latest;

		/**
		 * Eviction policy based on number of accesses.
		 */
		EvictionPolicy LEAST_FREQUENTLY_USED = entry -> entry.count;

		/**
		 * Eviction policy based on highest weight.
		 */
		EvictionPolicy WEIGHT = entry -> entry.weight;
	}

	/**
	 * Cache constraint.
	 */
	@FunctionalInterface
	public interface Constraint {
		/**
		 * @param cache Cache
		 * @return Whether this constraint is exceeded by the given cache
		 */
		boolean isExceeded(Cache<?, ?> cache);

		/**
		 * Unlimited cache.
		 */
		Constraint NONE = ignore -> false;

		/**
		 * Creates a constraint based on cache size.
		 * @param size Maximum size
		 * @return Size constraint
		 * @see Cache#size()
		 */
		static Constraint size(int size) {
			return cache -> cache.size() >= size;
		}

		/**
		 * Creates a constraint based on total cache weight.
		 * @param weight Maximum weight
		 * @return Weight constraint
		 * @see Cache#weight()
		 */
		static Constraint weight(int weight) {
			return cache -> cache.stats.weight >= weight;
		}
	}

	/**
	 * Factory for missing entries.
	 * @param <K> Key type
	 * @param <V> Value type
	 */
	@FunctionalInterface
	public interface Factory<K, V> {
		/**
		 * Retrieves a cache entry.
		 * @param key Key
		 * @return Value
		 */
		V get(K key);

		/**
		 * Weighs a new value.
		 * @param value Value to be weighed
		 * @return Weight of this entry (default is zero)
		 */
		default int weight(V value) {
			return 0;
		}

		/**
		 * Empty factory.
		 */
		Factory<?, ?> NONE = key -> {
			throw new UnsupportedOperationException();
		};
	}

	/**
	 * Cache statistics.
	 */
	public class Statistics extends AbstractObject {
		private int weight;
		private int hit;
		private int miss;
		private int errors;
		private int evictions;
		private int supplied;

		private Statistics() {
		}

		/**
		 * @return Total weight of this cache
		 */
		public int weight() {
			return weight;
		}

		/**
		 * @return Hit count
		 */
		public int hit() {
			return hit;
		}

		/**
		 * @return Miss count
		 */
		public int miss() {
			return miss;
		}

		/**
		 * @return Factory errors
		 */
		public int errors() {
			return errors;
		}

		/**
		 * @return Eviction count
		 */
		public int evictions() {
			return evictions;
		}

		/**
		 * @return Number of entries generated by the cache factory
		 */
		public int supplied() {
			return supplied;
		}
	}

	private final Map<K, Entry<V>> map;
	private final Constraint constraint;
	private final Comparator<Map.Entry<K, Entry<V>>> comparator;
	private final Factory<K, V> factory;
	private final Statistics stats = new Statistics();

	/**
	 * Constructor.
	 * @param map				Cache map
	 * @param constraint		Constraint
	 * @param policy			Eviction policy
	 * @param factory			Factory for new entries
	 */
	private Cache(Map<K, Entry<V>> map, Constraint constraint, EvictionPolicy policy, Factory<K, V> factory) {
		this.map = notNull(map);
		this.constraint = notNull(constraint);
		this.comparator = Comparator.comparing(e -> policy.score(e.getValue()));
		this.factory = notNull(factory);
	}

	/**
	 * @return Size of this cache
	 */
	public int size() {
		return map.size();
	}

	/**
	 * @return Cache statistics
	 */
	public Statistics statistics() {
		return stats;
	}

	/**
	 * @param key Key
	 * @return Whether this cache contains the given entry
	 */
	public boolean contains(K key) {
		return map.containsKey(key);
	}

	/**
	 * Looks up a cache entry.
	 * @param key Key
	 * @return Value or <tt>null</tt> if not present
	 */
	public synchronized V get(K key) {
		final Entry<V> entry = map.get(key);
		if(entry == null) {
			++stats.miss;
			return load(key);
		}
		else {
			entry.update();
			++entry.count;
			++stats.hit;
			return entry.value;
		}
	}

	/**
	 * Loads a missing entry from the factory.
	 * @param key Key
	 * @return Loaded value
	 */
	private synchronized V load(K key) {
		// Ignore if no factory
		if(factory == Factory.NONE) {
			return null;
		}

		// Load from factory
		final V value = factory.get(key);

		// Check loaded result
		if(value == null) {
			++stats.errors;
			return null;
		}

		// Evict stale entries
		if(!map.isEmpty() && constraint.isExceeded(this)) {
			evict();
		}

		// Create new entry
		final int weight = factory.weight(value);
		final Entry<V> entry = new Entry<>(value, weight);
		map.put(key, entry);

		// Update stats
		++stats.supplied;
		stats.weight += weight;

		return value;
	}

	/**
	 * Evicts stale entries.
	 */
	private synchronized void evict() {
		// Order cache eviction policy
		final Queue<K> keys = map.entrySet().stream()
			.sorted(comparator)
			.map(Map.Entry::getKey)
			.collect(Collectors.toCollection(LinkedList::new));

		// Evict until constraint satisfied
		while(true) {
			// Evict stale entry
			final K next = keys.poll();
			removeLocal(next);
			++stats.evictions;

			// Stop if no more entries or constraint satisfied
			if(map.isEmpty()) break;
			if(!constraint.isExceeded(this)) break;
		}
	}

	/**
	 * Adds a new cache entry.
	 * <p>
	 * Note that the weight of the entry is <b>zero</b></li>
	 * <p>
	 * @param key		Key
	 * @param value		Value
	 * @throws IllegalArgumentException if an entry with the given key is already present
	 */
	public synchronized void add(K key, V value) {
		if(map.containsKey(key)) throw new IllegalArgumentException("Duplicate key: " + key);
		map.put(key, new Entry<>(value, 0));
	}

	/**
	 * Adds a new cache entry loaded by the configured factory.
	 * @param key Key
	 * @throws IllegalArgumentException if an entry with the given key is already present
	 * @throws IllegalArgumentException if the factory is {@link Factory#NONE}
	 */
	public synchronized void add(K key) {
		if(map.containsKey(key)) throw new IllegalArgumentException("Duplicate key: " + key);
		load(key);
	}

	/**
	 * Removes a cache entry.
	 * @param key Key
	 * @throws IllegalArgumentException if the entry is not present
	 */
	public synchronized void remove(K key) {
		if(!map.containsKey(key)) throw new IllegalArgumentException("Entry not present: " + key);
		removeLocal(key);
	}

	/**
	 * Removes an entry.
	 * @param key Key
	 */
	private void removeLocal(K key) {
		final Entry<V> entry = map.remove(key);
		stats.weight -= entry.weight;
		assert stats.weight >= 0;
	}

	/**
	 * Removes <b>all</b> entries from this cache.
	 */
	public synchronized void clear() {
		map.clear();
		stats.weight = 0;
	}

	@Override
	public String toString() {
		return new ToStringBuilder(this).append("size", size()).append("stats", stats).toString();
	}

	/**
	 * Builder for a cache.
	 */
	public static class Builder<K, V> {
		private Supplier<Map<K, Entry<V>>> supplier = () -> new HashMap<>();
		private Constraint constraint = Constraint.NONE;
		private EvictionPolicy policy = EvictionPolicy.NONE;
		private Factory<K, V> factory = key -> null;

		/**
		 * Sets the underlying map implementation for this cache.
		 * @param map Map
		 */
		public Builder<K, V> cache(Supplier<Map<K, Entry<V>>> supplier) {
			this.supplier = notNull(supplier);
			return this;
		}

		/**
		 * Sets the constraint for this cache.
		 * @param constraint Cache constraint
		 */
		public Builder<K, V> constraint(Constraint constraint) {
			this.constraint = constraint;
			return this;
		}

		/**
		 * Sets the eviction policy of this cache.
		 * @param policy Eviction policy
		 */
		public Builder<K, V> policy(EvictionPolicy policy) {
			this.policy = policy;
			return this;
		}

		/**
		 * Sets the factory for missing entries.
		 * @param factory Entry factory
		 */
		public Builder<K, V> factory(Factory<K, V> factory) {
			this.factory = factory;
			return this;
		}

		/**
		 * Constructs this cache.
		 * @return New cache
		 */
		public Cache<K, V> build() {
			return new Cache<>(supplier.get(), constraint, policy, factory);
		}
	}
}
